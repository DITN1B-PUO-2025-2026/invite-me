name: Invite User and Manage Issue Status
on:
  issues:
    # Triggers on new issues and issue edits (for key check/recheck)
    types: [opened, edited] 
  issue_comment:
    # Triggers when a user replies with a new key in a comment
    types: [created]

jobs:
  invite:
    runs-on: ubuntu-latest
    permissions:
      issues: write # Grants GITHUB_TOKEN permission to post comments AND close issues
      contents: read
    
    steps:
      - name: Determine Content Source and Extract Key
        id: determine_content
        env:
          EXPECTED_KEY: ${{ secrets.INVITE_LABEL_KEY }}
        run: |
          # Prioritize the new comment body if it exists and is not from a bot
          ISSUE_BODY="${{ github.event.issue.body }}"
          COMMENT_BODY="${{ github.event.comment.body }}"
          
          CONTENT_TO_CHECK="$ISSUE_BODY"
          if [ -n "$COMMENT_BODY" ] && [ "${{ github.event.comment.user.type }}" != "Bot" ]; then
              CONTENT_TO_CHECK="$COMMENT_BODY"
              echo "Checking new comment content."
          else
              echo "Checking issue body content."
          fi
          
          # Robust extraction: find 'INVITE_KEY:' and extract the value after it.
          INVITE_KEY=$(echo "$CONTENT_TO_CHECK" | grep -i 'INVITE_KEY:' | awk -F':' '{print $2}' | xargs)
          EXPECTED_KEY_CLEAN=$(echo "$EXPECTED_KEY" | xargs)
          
          echo "Expected Key: $EXPECTED_KEY_CLEAN"
          echo "User Key: $INVITE_KEY"
          
          if [ -n "$INVITE_KEY" ] && [ "$INVITE_KEY" == "$EXPECTED_KEY_CLEAN" ]; then
            echo "key_matched=true" >> $GITHUB_OUTPUT
            # Store the user's login for the Discord notification step
            echo "issue_user=${{ github.event.issue.user.login }}" >> $GITHUB_OUTPUT 
          else
            echo "key_matched=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Invite User (using PAT)
        uses: actions/github-script@v6
        id: invite
        # Only run this step if the key was matched
        if: steps.determine_content.outputs.key_matched == 'true'
        with:
          github-token: ${{ secrets.INVITE_TOKEN }} 
          script: |
            const user = context.payload.issue.user.login;
            const org = 'DITN1B-PUO-2025-2026';
            let message = '';
            let shouldClose = false;

            // Check if the user is already an active member/admin
            const { data: userOrg } = await github.rest.orgs.getMembershipForUser({
              org: org,
              username: user,
            }).catch(() => ({ data: { role: null } })); 

            if (userOrg.role === 'admin' || userOrg.state === 'active') {
                message = `Hello @${user}, you are **already an active member** of the ${org} organization :D.`;
                shouldClose = true;
            } else {
                try {
                  // Attempt to invite the user
                  await github.rest.orgs.setMembershipForUser({
                    org: org,
                    username: user,
                    role: 'member'
                  });
                  
                  message = `**Welcome to ${org}, @${user}!** ðŸŽ‰ You have been invited successfully.`;
                  shouldClose = true;

                } catch (error) {
                   console.error('Invite failed:', error);
                   message = `**ERROR:** The invite failed with status **${error.status}**. Please check the INVITE_TOKEN scope.`;
                   shouldClose = false;
                }
            }
            
            core.setOutput('comment_body', message);
            core.setOutput('close_issue', shouldClose);

      - name: Post Comment and Manage Issue Status
        uses: actions/github-script@v6
        id: comment_and_close
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} 
          script: |
            const isInviteStepSkipped = '${{ steps.invite.outcome }}' === 'skipped';
            const keyMatched = '${{ steps.determine_content.outputs.key_matched }}';
            let commentBody = '';
            let shouldClose = false;
            
            // Get output from the invite step (if it ran)
            if (!isInviteStepSkipped) {
                commentBody = '${{ steps.invite.outputs.comment_body }}';
                shouldClose = '${{ steps.invite.outputs.close_issue }}' === 'true';
            } else if (keyMatched === 'false') {
                // If the key failed, post a failure comment
                commentBody = "The secret key provided is incorrect. Please ensure you have the correct key and the format is **INVITE_KEY: YOUR\\_KEY**. The issue remains open.";
                shouldClose = false;
            } else {
                return; // Nothing happened, do nothing
            }
            
            // 1. Post the result as a comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });

            // 2. Close the issue if the flag is true
            if (shouldClose) {
                await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    state: 'closed'
                });
                console.log(`Issue ${context.issue.number} closed successfully.`);
            }
            core.setOutput('issue_was_closed', shouldClose);

      - name: Generate Random Label Key
        id: generate_key
        if: steps.comment_and_close.outputs.issue_was_closed == 'true'
        run: |
          # Generates a 32-character hexadecimal string
          NEW_KEY=$(openssl rand -hex 4)
          echo "::add-mask::$NEW_KEY"
          echo "NEW_KEY=$NEW_KEY" >> $GITHUB_OUTPUT
      
      - name: Update Repository Secret
        if: steps.comment_and_close.outputs.issue_was_closed == 'true'
        env:
          GH_TOKEN: ${{ secrets.PAT_FOR_SECRETS_UPDATE }}
          NEW_KEY: ${{ steps.generate_key.outputs.NEW_KEY }}
          SECRET_NAME: INVITE_LABEL_KEY
        run: |
          # Use the GitHub CLI to update the secret
          gh secret set $SECRET_NAME --body "$NEW_KEY" -R $GITHUB_REPOSITORY
          echo "ðŸ”„ Secret ${{ env.SECRET_NAME }} has been updated."


      - name: Send Successful Invite Notification to Discord
        uses: actions/github-script@v6
        # Only run if the issue was successfully closed (meaning the invite succeeded)
        if: steps.comment_and_close.outputs.issue_was_closed == 'true'
        env:
          NEW_KEY: ${{ steps.generate_key.outputs.NEW_KEY }}
          DISCORD_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
          BOT_AUTH_HEADER: ${{ secrets.BOT_AUTHORIZATION_HEADER }}
          INVITED_USER: ${{ steps.determine_content.outputs.issue_user }}
        with:
          script: |
            const discordUrl = process.env.DISCORD_URL;
            const authHeader = process.env.BOT_AUTH_HEADER;
            const invitedUser = process.env.INVITED_USER;
            const org = 'DITN1B-PUO-2025-2026';
            
            // Construct the Discord payload (simple message and rich embed)
            const payload = {
              content: `**New Member Alert!** ðŸ””`,
              embeds: [{
                title: `âœ… User Invited and Issue Closed`,
                description: `**@${invitedUser}** has successfully joined the **${org}** organization.`,
                color: 3066993, // A nice green color
                fields: [
                  {
                    name: "GitHub User",
                    value: `[${invitedUser}](https://github.com/${invitedUser})`,
                    inline: true
                  },
                  {
                    name: "Issue Closed",
                    value: `#${context.issue.number}`,
                    inline: true
                  }
                ],
                // Adds a time-of-event stamp
                timestamp: (new Date()).toISOString(), 
              }]
              content: `@everyone **ðŸ”‘ GitHub Invite Key Rotated!**',
              embeds: [{
                title: "New Organization Invitation Label Key",
                description: "The key has been updated. Use this new key in an issue >",
                color: 3447003,
                fields: [{
                  name: "ðŸ”‘ Current Key",
                  value: key,
                  inline: false
                }],
                footer: {
                  // Use the localized time string and manually append the MYT suffix
                  text: `Key updated at ${mytTime} MYT`
                }
              }]
            };

            // Send the Discord notification
            const response = await fetch(discordUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader 
              },
              body: JSON.stringify(payload)
            });

            if (!response.ok) {
              const responseBody = await response.text();
              console.error(`Discord API failed: ${response.status} - ${responseBody}`);
              // Note: We don't throw an error here, as a failed notification 
              // shouldn't undo the successful invite and issue closure.
            } else {
              console.log('Successfully sent Discord notification for new member.');
            }