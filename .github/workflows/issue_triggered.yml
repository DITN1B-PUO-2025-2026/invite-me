name: Invite User and Manage Issue Status
on:
  issues:
    # Triggers on new issues and issue edits (for key check/recheck)
    types: [opened, edited] 
  issue_comment:
    # Triggers when a user replies with a new key in a comment
    types: [created]

jobs:
  invite:
    runs-on: ubuntu-latest
    permissions:
      issues: write # Grants GITHUB_TOKEN permission to post comments AND close issues
      contents: read
    
    steps:
      - name: Determine Content Source and Extract Key
        id: determine_content
        env:
          EXPECTED_KEY: ${{ secrets.INVITE_LABEL_KEY }}
        run: |
          # Prioritize the new comment body if it exists and is not from a bot
          ISSUE_BODY="${{ github.event.issue.body }}"
          COMMENT_BODY="${{ github.event.comment.body }}"
          
          CONTENT_TO_CHECK="$ISSUE_BODY"
          if [ -n "$COMMENT_BODY" ] && [ "${{ github.event.comment.user.type }}" != "Bot" ]; then
              CONTENT_TO_CHECK="$COMMENT_BODY"
              echo "Checking new comment content."
          else
              echo "Checking issue body content."
          fi
          
          # Robust extraction: find 'INVITE_KEY:' and extract the value after it.
          INVITE_KEY=$(echo "$CONTENT_TO_CHECK" | grep -i 'INVITE_KEY:' | awk -F':' '{print $2}' | xargs)
          EXPECTED_KEY_CLEAN=$(echo "$EXPECTED_KEY" | xargs)
          
          echo "Expected Key: $EXPECTED_KEY_CLEAN"
          echo "User Key: $INVITE_KEY"
          
          if [ -n "$INVITE_KEY" ] && [ "$INVITE_KEY" == "$EXPECTED_KEY_CLEAN" ]; then
            echo "key_matched=true" >> $GITHUB_OUTPUT
            echo "issue_user=${{ github.event.issue.user.login }}" >> $GITHUB_OUTPUT
          else
            echo "key_matched=false" >> $GITHUB_OUTPUT
          fi
          
      - name: Invite User (using PAT)
        uses: actions/github-script@v6
        id: invite
        # Only run this step if the key was matched
        if: steps.determine_content.outputs.key_matched == 'true'
        with:
          github-token: ${{ secrets.INVITE_TOKEN }} 
          script: |
            const user = context.payload.issue.user.login;
            const org = 'DITN1B-PUO-2025-2026';
            let message = '';
            let shouldClose = false;

            // Check if the user is already an active member/admin
            const { data: userOrg } = await github.rest.orgs.getMembershipForUser({
              org: org,
              username: user,
            }).catch(() => ({ data: { role: null } })); 

            if (userOrg.role === 'admin' || userOrg.state === 'active') {
                message = `Hello @${user}, you are **already an active member** of the ${org} organization :D.`;
                shouldClose = true;
            } else {
                try {
                  // Attempt to invite the user
                  await github.rest.orgs.setMembershipForUser({
                    org: org,
                    username: user,
                    role: 'member'
                  });
                  
                  message = `**Welcome to ${org}, @${user}!** ðŸŽ‰ You have been invited successfully.`;
                  shouldClose = true;

                } catch (error) {
                   console.error('Invite failed:', error);
                   message = `**ERROR:** The invite failed with status **${error.status}**. Please check the INVITE_TOKEN scope.`;
                   shouldClose = false;
                }
            }
            
            core.setOutput('comment_body', message);
            core.setOutput('close_issue', shouldClose);

      - name: Post Comment and Manage Issue Status
        uses: actions/github-script@v6
        id: comment_and_close
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }} 
          script: |
            const isInviteStepSkipped = '${{ steps.invite.outcome }}' === 'skipped';
            const keyMatched = '${{ steps.determine_content.outputs.key_matched }}';
            let commentBody = '';
            let shouldClose = false;
            
            if (!isInviteStepSkipped) {
                commentBody = '${{ steps.invite.outputs.comment_body }}';
                shouldClose = '${{ steps.invite.outputs.close_issue }}' === 'true';
            } else if (keyMatched === 'false') {
                // If the invite step was skipped because the key failed, post a failure comment
                commentBody = "The secret key provided is incorrect. Please ensure you have the correct key and the format is **INVITE_KEY: YOUR\_KEY**. The issue remains open.";
                shouldClose = false;
            } else {
                return; 
            }
            
            // 1. Post the result as a comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });

            // 2. Close the issue if the flag is true
            if (shouldClose) {
                await github.rest.issues.update({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    issue_number: context.issue.number,
                    state: 'closed'
                });
                console.log(`Issue ${context.issue.number} closed successfully.`);
            }
            core.setOutput('issue_was_closed', shouldClose);

      - name: Update new key and timezone info if issue was closed
        uses: actions/github-script@v6
        # Run only if the issue was successfully closed in the previous step
        if: steps.comment_and_close.outputs.issue_was_closed == 'true'
        with:
          timezone: Asia/Kuala_Lumpur

      - name: Generate Random Label Key
        id: generate_key
        run: |
          # Generates a 32-character hexadecimal string
          NEW_KEY=$(openssl rand -hex 4)
          echo "::add-mask::$NEW_KEY"
          echo "NEW_KEY=$NEW_KEY" >> $GITHUB_OUTPUT

      - name: Update Repository Secret
        env:
          GH_TOKEN: ${{ secrets.PAT_FOR_SECRETS_UPDATE }}
          NEW_KEY: ${{ steps.generate_key.outputs.NEW_KEY }}
          SECRET_NAME: INVITE_LABEL_KEY
        run: |
          # Use the GitHub CLI to update the secret
          gh secret set $SECRET_NAME --body "$NEW_KEY" -R $GITHUB_REPOSITORY
          echo "ðŸ”„ Secret ${{ env.SECRET_NAME }} has been updated."

      - name: Send New Key to Discord via API (Non-Shell)
        id: send_discord
        uses: actions/github-script@v6
        env:
          NEW_KEY: ${{ steps.generate_key.outputs.NEW_KEY }}
          BOT_AUTH_HEADER: ${{ secrets.BOT_AUTHORIZATION_HEADER }}
          DISCORD_URL: ${{ secrets.DISCORD_WEBHOOK_URL }}
        with:
          script: |
            const key = process.env.NEW_KEY;
            const authHeader = process.env.BOT_AUTH_HEADER;
            const discordUrl = process.env.DISCORD_URL;
            
            // ðŸš¨ Timezone FIX: Use sv-SE locale for YYYY-MM-DD HH:MM format in Kuala Lumpur timezone (MYT) ðŸš¨
            const mytTime = new Date().toLocaleString('en-GB', {
              timeZone: 'Asia/Kuala_Lumpur',
              day: '2-digit',
              month: '2-digit',
              year: 'numeric',
              hour: '2-digit',
              minute: '2-digit',
              hour12: true // This ensures AM/PM is used
            });
            
            // 1. Construct the JSON payload (JavaScript object)
            const payload = {
              content: "@everyone **ðŸ”‘ GitHub Invite Key Rotated!**",
              embeds: [{
                title: "New user detected",
                description: "The key has been updated. Use this new key in an issue >",
                color: 3447003,
                fields: [{
                  name: "ðŸ”‘ Current Key",
                  value: key,
                  inline: false
                }],
                footer: {
                  // Use the localized time string and manually append the MYT suffix
                  text: `Key updated at ${mytTime} MYT`
                }
              }]
            };
            
            // 2. Use fetch (Node's standard HTTP client) to send the request
            const response = await fetch(discordUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Authorization': authHeader
              },
              body: JSON.stringify(payload)
            });

            // 3. Fail the step if the API call fails (e.g., HTTP 400, 403)
            if (!response.ok) {
              const responseBody = await response.text();
              throw new Error(`Discord API failed with status ${response.status}: ${responseBody}`);
            }